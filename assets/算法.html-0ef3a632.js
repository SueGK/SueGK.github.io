import{_ as o,Y as t,Z as i,a2 as e}from"./framework-cef54de9.js";const n={},r=e('<hr><h2 id="article-truetitle-算法-binary-searchicon-fa6-solid-repeat" tabindex="-1"><a class="header-anchor" href="#article-truetitle-算法-binary-searchicon-fa6-solid-repeat" aria-hidden="true">#</a> article: true title: 算法: Binary Search icon: fa6-solid:repeat</h2><ul><li>binary search，也称作二分法（half-interval search），每次划分一半进行下一步搜索，所以时间复杂度无非就是while循环的次数！</li><li><img src="https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2FFemFarm%2FrI6sP7NOWn.png?alt=media&amp;token=8a73e9d9-9606-417b-b00d-afe1fcf63b2b" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption><ul><li>maximum comparisons are dependent on the <strong>height of a tree</strong> <code>logn</code>，极端情况下我们需要查找所有n个elements得到target. <ul><li>第一次折半查找的为区间<strong>n</strong>，比较次数 <code>c=1</code>（<strong>中间值可能的个数为：</strong><code>2^c - 1 = 1</code>， index: [8]）</li><li>第二次折半查找的为区间<strong>n/2</strong>，比较次数 <code>c=2</code>（<strong>中间值可能的个数为：</strong><code>2^c - 1 = 3</code>，index: [8, 4, 12]） <ul><li>if <code>target &lt;= mid point</code>: (left point, mid point-1) 即( 1, 7)</li><li><strong>or</strong> <code>target &gt;= mid point</code>: (mid point+1, right point) 即( 9, 15)</li><li>一共可能的区间个数为<strong>2</strong> ， 即( 1, 7) or (9, 15)</li></ul></li><li>第三次次折半查找的为区间<strong>n/4</strong>，比较次数 <code>c=3</code>（<strong>中间值可能的个数为：</strong><code>2^c - 1 = 7</code>，index: [8, 4, 12, 2, 6, 10, 14]） <ul><li>if <code>target &lt;= mid point</code>: (left point, mid point-1)</li><li><strong>or</strong> <code>target &gt;= mid point</code>: (mid point+1, right point)</li><li>一共可能的区间个数为<strong>4</strong> ， 即( 1, 3) or (5, 7) or ( 9, 11) or (13, 15)</li></ul></li><li>第四次次折半查找的为区间<strong>n/8</strong>，比较次数 <code>c=4</code>（<strong>中间值可能的个数为：</strong><code>2^c - 1 = 15</code>，index: [8, 4, 12, 2, 6, 10, 14, 1, 3, 5, 7, 9, 11, 13, 15]） <ul><li>if <code>target &lt;= mid point</code>: (left point, mid point-1)</li><li><strong>or</strong> <code>target &gt;= mid point</code>: (mid point+1, right point)</li><li>一共可能的区间个数为<strong>8</strong> ， 即 (1,1) or (3,3) or (5,5) or (7,7) or (9,9) or (11,11) or (13,13) or (15,15)</li><li>数组只余一个元素无法再分，计算结束。</li><li>此时<strong>中间值可能的个数=元素总个数len(nums)</strong>, 算法经历了所有可能值</li></ul></li></ul></li><li>总共有n个元素，每次查找的区间大小为n，n/2，n/4，…，n/2^c 且2^c_max - 1 = len(nums) 可得 <code>c=log2(n+1), n+1为常数所以可以把它看作c=log2(n)</code>,（ <strong>c为比较的次数or循环的次数or二分树的高度</strong>），log2(n)中2可以省略所以时间复杂度为 <code>O(logn)</code><ul><li>minimum time of binary search: 1次比较得到target, <code>O(1)</code></li><li>maximum time of binary search: log(n)次比较得到target, <code>O(logn)</code></li></ul></li></ul></li></ul>',3),l=[r];function c(a,d){return t(),i("div",null,l)}const g=o(n,[["render",c],["__file","算法.html.vue"]]);export{g as default};
