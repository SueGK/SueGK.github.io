const t=JSON.parse('{"key":"v-2a405ee0","path":"/Algorithm/%E7%AE%97%E6%B3%95.html","title":"","lang":"en-US","frontmatter":{"description":"article: true title: 算法: Binary Search icon: fa6-solid:repeat binary search，也称作二分法（half-interval search），每次划分一半进行下一步搜索，所以时间复杂度无非就是while循环的次数！ img maximum comparisons are dependent on the height of a tree logn，极端情况下我们需要查找所有n个elements得到target. 第一次折半查找的为区间n，比较次数 c=1（中间值可能的个数为：2^c - 1 = 1， index: [8]） 第二次折半查找的为区间n/2，比较次数 c=2（中间值可能的个数为：2^c - 1 = 3，index: [8, 4, 12]） if target &lt;= mid point: (left point, mid point-1) 即( 1, 7) or target &gt;= mid point: (mid point+1, right point) 即( 9, 15) 一共可能的区间个数为2 ， 即( 1, 7) or (9, 15) 第三次次折半查找的为区间n/4，比较次数 c=3（中间值可能的个数为：2^c - 1 = 7，index: [8, 4, 12, 2, 6, 10, 14]） if target &lt;= mid point: (left point, mid point-1) or target &gt;= mid point: (mid point+1, right point) 一共可能的区间个数为4 ， 即( 1, 3) or (5, 7) or ( 9, 11) or (13, 15) 第四次次折半查找的为区间n/8，比较次数 c=4（中间值可能的个数为：2^c - 1 = 15，index: [8, 4, 12, 2, 6, 10, 14, 1, 3, 5, 7, 9, 11, 13, 15]） if target &lt;= mid point: (left point, mid point-1) or target &gt;= mid point: (mid point+1, right point) 一共可能的区间个数为8 ， 即 (1,1) or (3,3) or (5,5) or (7,7) or (9,9) or (11,11) or (13,13) or (15,15) 数组只余一个元素无法再分，计算结束。 此时中间值可能的个数=元素总个数len(nums), 算法经历了所有可能值 总共有n个元素，每次查找的区间大小为n，n/2，n/4，…，n/2^c 且2^c_max - 1 = len(nums) 可得 c=log2(n+1), n+1为常数所以可以把它看作c=log2(n),（ c为比较的次数or循环的次数or二分树的高度），log2(n)中2可以省略所以时间复杂度为 O(logn) minimum time of binary search: 1次比较得到target, O(1) maximum time of binary search: log(n)次比较得到target, O(logn)","head":[["meta",{"property":"og:url","content":"https://suegk.github.io/Algorithm/%E7%AE%97%E6%B3%95.html"}],["meta",{"property":"og:site_name","content":"Digest Today"}],["meta",{"property":"og:description","content":"article: true title: 算法: Binary Search icon: fa6-solid:repeat binary search，也称作二分法（half-interval search），每次划分一半进行下一步搜索，所以时间复杂度无非就是while循环的次数！ img maximum comparisons are dependent on the height of a tree logn，极端情况下我们需要查找所有n个elements得到target. 第一次折半查找的为区间n，比较次数 c=1（中间值可能的个数为：2^c - 1 = 1， index: [8]） 第二次折半查找的为区间n/2，比较次数 c=2（中间值可能的个数为：2^c - 1 = 3，index: [8, 4, 12]） if target &lt;= mid point: (left point, mid point-1) 即( 1, 7) or target &gt;= mid point: (mid point+1, right point) 即( 9, 15) 一共可能的区间个数为2 ， 即( 1, 7) or (9, 15) 第三次次折半查找的为区间n/4，比较次数 c=3（中间值可能的个数为：2^c - 1 = 7，index: [8, 4, 12, 2, 6, 10, 14]） if target &lt;= mid point: (left point, mid point-1) or target &gt;= mid point: (mid point+1, right point) 一共可能的区间个数为4 ， 即( 1, 3) or (5, 7) or ( 9, 11) or (13, 15) 第四次次折半查找的为区间n/8，比较次数 c=4（中间值可能的个数为：2^c - 1 = 15，index: [8, 4, 12, 2, 6, 10, 14, 1, 3, 5, 7, 9, 11, 13, 15]） if target &lt;= mid point: (left point, mid point-1) or target &gt;= mid point: (mid point+1, right point) 一共可能的区间个数为8 ， 即 (1,1) or (3,3) or (5,5) or (7,7) or (9,9) or (11,11) or (13,13) or (15,15) 数组只余一个元素无法再分，计算结束。 此时中间值可能的个数=元素总个数len(nums), 算法经历了所有可能值 总共有n个元素，每次查找的区间大小为n，n/2，n/4，…，n/2^c 且2^c_max - 1 = len(nums) 可得 c=log2(n+1), n+1为常数所以可以把它看作c=log2(n),（ c为比较的次数or循环的次数or二分树的高度），log2(n)中2可以省略所以时间复杂度为 O(logn) minimum time of binary search: 1次比较得到target, O(1) maximum time of binary search: log(n)次比较得到target, O(logn)"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:updated_time","content":"2024-08-28T06:01:58.000Z"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"article:modified_time","content":"2024-08-28T06:01:58.000Z"}]]},"headers":[{"level":2,"title":"article: truetitle: 算法: Binary Searchicon: fa6-solid:repeat","slug":"article-truetitle-算法-binary-searchicon-fa6-solid-repeat","link":"#article-truetitle-算法-binary-searchicon-fa6-solid-repeat","children":[]}],"git":{"createdTime":1724824918000,"updatedTime":1724824918000,"contributors":[{"name":"SueGK","email":"71711489+SueGK@users.noreply.github.com","commits":1}]},"readingTime":{"minutes":1.85,"words":554},"filePathRelative":"Algorithm/算法.md","localizedDate":"August 28, 2024","excerpt":"<hr>\\n<h2> article: true\\ntitle: 算法: Binary Search\\nicon: fa6-solid:repeat</h2>\\n<ul>\\n<li>binary search，也称作二分法（half-interval search），每次划分一半进行下一步搜索，所以时间复杂度无非就是while循环的次数！</li>\\n<li><img src=\\"https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2FFemFarm%2FrI6sP7NOWn.png?alt=media&amp;token=8a73e9d9-9606-417b-b00d-afe1fcf63b2b\\" alt=\\"img\\" tabindex=\\"0\\" loading=\\"lazy\\"><figcaption>img</figcaption>\\n<ul>\\n<li>maximum comparisons are dependent on the <strong>height of a tree</strong> <code>logn</code>，极端情况下我们需要查找所有n个elements得到target.\\n<ul>\\n<li>第一次折半查找的为区间<strong>n</strong>，比较次数 <code>c=1</code>（<strong>中间值可能的个数为：</strong><code>2^c - 1 = 1</code>， index: [8]）</li>\\n<li>第二次折半查找的为区间<strong>n/2</strong>，比较次数 <code>c=2</code>（<strong>中间值可能的个数为：</strong><code>2^c - 1 = 3</code>，index: [8, 4, 12]）\\n<ul>\\n<li>if <code>target &lt;= mid point</code>: (left point, mid point-1) 即( 1, 7)</li>\\n<li><strong>or</strong> <code>target &gt;= mid point</code>: (mid point+1, right point) 即( 9, 15)</li>\\n<li>一共可能的区间个数为<strong>2</strong> ， 即( 1, 7) or (9, 15)</li>\\n</ul>\\n</li>\\n<li>第三次次折半查找的为区间<strong>n/4</strong>，比较次数 <code>c=3</code>（<strong>中间值可能的个数为：</strong><code>2^c - 1 = 7</code>，index: [8, 4, 12, 2, 6, 10, 14]）\\n<ul>\\n<li>if <code>target &lt;= mid point</code>: (left point, mid point-1)</li>\\n<li><strong>or</strong> <code>target &gt;= mid point</code>: (mid point+1, right point)</li>\\n<li>一共可能的区间个数为<strong>4</strong> ， 即( 1, 3) or (5, 7) or ( 9, 11) or (13, 15)</li>\\n</ul>\\n</li>\\n<li>第四次次折半查找的为区间<strong>n/8</strong>，比较次数 <code>c=4</code>（<strong>中间值可能的个数为：</strong><code>2^c - 1 = 15</code>，index: [8, 4, 12, 2, 6, 10, 14, 1, 3, 5, 7, 9, 11, 13, 15]）\\n<ul>\\n<li>if <code>target &lt;= mid point</code>: (left point, mid point-1)</li>\\n<li><strong>or</strong> <code>target &gt;= mid point</code>: (mid point+1, right point)</li>\\n<li>一共可能的区间个数为<strong>8</strong> ， 即 (1,1) or (3,3) or (5,5) or (7,7) or (9,9) or (11,11) or (13,13) or (15,15)</li>\\n<li>数组只余一个元素无法再分，计算结束。</li>\\n<li>此时<strong>中间值可能的个数=元素总个数len(nums)</strong>, 算法经历了所有可能值</li>\\n</ul>\\n</li>\\n</ul>\\n</li>\\n<li>总共有n个元素，每次查找的区间大小为n，n/2，n/4，…，n/2^c 且2^c_max - 1 = len(nums)\\n可得 <code>c=log2(n+1), n+1为常数所以可以把它看作c=log2(n)</code>,（ <strong>c为比较的次数or循环的次数or二分树的高度</strong>），log2(n)中2可以省略所以时间复杂度为 <code>O(logn)</code>\\n<ul>\\n<li>minimum time of binary search: 1次比较得到target, <code>O(1)</code></li>\\n<li>maximum time of binary search: log(n)次比较得到target, <code>O(logn)</code></li>\\n</ul>\\n</li>\\n</ul>\\n</li>\\n</ul>","autoDesc":true}');export{t as data};
